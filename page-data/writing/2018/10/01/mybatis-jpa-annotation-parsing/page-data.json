{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/writing/2018/10/01/mybatis-jpa-annotation-parsing",
    "result": {"data":{"post":{"slug":"/2018/10/01/mybatis-jpa-annotation-parsing","title":"MyBatipse XML Generate ResultSet from JPA Annotations","date":"Oct 01, 2018","tags":[{"name":"Eclipse","slug":"eclipse"},{"name":"Mybatis","slug":"mybatis"},{"name":"JPA","slug":"jpa"}],"description":"My new company, Standardbred Canada, uses Mybatis to manage their Data Access.  After getting used to the environment I found I needed a better/faster way to write mapper files.  I was able to throw together a JPA backed mapping plugin for Eclipse.","canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"MyBatipse XML Generate ResultSet from JPA Annotations\",\n  \"description\": \"My new company, Standardbred Canada, uses Mybatis to manage their Data Access.  After getting used to the environment I found I needed a better/faster way to write mapper files.  I was able to throw together a JPA backed mapping plugin for Eclipse.\",\n  \"date\": \"2018-10-01T00:00:00.000Z\",\n  \"tags\": [\"Eclipse\", \"Mybatis\", \"JPA\"],\n  \"slug\": \"/2018/10/01/mybatis-jpa-annotation-parsing\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/mybatis/mybatipse\"\n  }, \"My Batipse\"), \" is a great Eclipse plugin that provides:\\nValidation\\nGeneration\\nTools\\nwhile working with Mybatis XML files. When I started at \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.standardbredcanada.org\"\n  }, \"Standardbred Canada\"), \" the DB library of choice was Mybatis (which I'd never used before) but quickly started to love it.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The primary reason that MyBatis was chosen due to it's ability to map legacy tables to updated domain models with ease. In order to quickly replicate the legacy functionality, the ability to write XML based SQL was a requirement.\")), mdx(\"p\", null, \"The primary feature that I started using was \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Result Map generation\"), \" option.\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"770px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"31.666666666666664%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA30lEQVQY032Oy26DQAxF+f9va7tLVagEtDxTYzw4wzBPT0UjRV3lrCxd69xbGOtQH8SGyMEqC8luUv6D+Nb0gwJFa1wx0hq0DrSJdXJ/KLTem+9+gtUFOXw6vISUlVK8bXyYCVZqFphN+5Vg2Gnm6ZoBU5KzoNi1/qzKcRzvMpHTiohEpHZTd8PU/sDi6i7PEOnK/RjqLi8qRpHipnXTtryxdc57n/9hXUCl2Fifso/ikriYzztlG3KUXCDSy+tbVVWX98tHWfbDAACPCc85Zy8AzExEiKiUstY+YpFnkl/iM1iMtIrCNgAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Result Map Generation\",\n    \"title\": \"Result Map Generation\",\n    \"src\": \"/static/64425cb03f3e0c5f8dcbbafad8d7eda7/3ae48/ac-results.png\",\n    \"srcSet\": [\"/static/64425cb03f3e0c5f8dcbbafad8d7eda7/5243c/ac-results.png 240w\", \"/static/64425cb03f3e0c5f8dcbbafad8d7eda7/ab158/ac-results.png 480w\", \"/static/64425cb03f3e0c5f8dcbbafad8d7eda7/3ae48/ac-results.png 770w\"],\n    \"sizes\": \"(max-width: 770px) 100vw, 770px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\",\n    \"decoding\": \"async\"\n  }), \"\\n    \")), mdx(\"h2\", null, \"Review of MyBatipse Feature\"), mdx(\"p\", null, \"The functionality was pretty basic, it would reflectively inspect the domain model fields, and create the result mapping for this item. One of the major problems was, that this did a direct mapping of name to column, which in our case (and most cases) wasn't generally the case. For example, if the object I was attempting to query was:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"public class Address {\\n    private String address1;\\n    private String address2;\\n    ...\\n}\\n\")), mdx(\"p\", null, \"with the matching result map:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \"<resultMap>\\n   <result property=\\\"address1\\\" column=\\\"address1\\\"/>\\n   <result property=\\\"address2\\\" column=\\\"address2\\\"/>\\n   ...\\n</resulMap>\\n\")), mdx(\"p\", null, \"the issue is that our tables are defined a little differently:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sql\"\n  }, \"select ad_addr1, add_addr2, ... from address\\n\")), mdx(\"p\", null, \"the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resultMap\"), \" still required a bunch of manual edits. I could choose to either update the SQL to include aliases matching the Java \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Address\"), \" but that would get hectic when working with collections and associations.\"), mdx(\"h2\", null, \"JPA Annotations\"), mdx(\"p\", null, \"I figured it would be easier to add JPA annotations to my domain models, as this would provide:\\nthe ability to maybe switch away from MyBatis down the road\\nin source documentation for easy lookup (until this point columns were \\\"documented\\\" by appending \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"private String address; // ad_addr1\"), \" \\uD83D\\uDE41\\nPlus it would give me a chance to take a look at how and what MyBatipse was doing - and learning something new is never bad. This is still a work in progress, it's crude and I want to make it better before submitting a pull request \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/kenjdavidson/mybatipse/tree/jpa-mapping\"\n  }, \"https://github.com/kenjdavidson/mybatipse/tree/jpa-mapping\"), \".\"), mdx(\"p\", null, \"When installing and using this version of MyBatipse you have the following available:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"@Entity\\n@Table(name=\\\"address\\\")\\npublic class Address {\\n    @Id\\n    @Column(name=\\\"ad_id\\\")\\n    private long id;\\n\\n    @Column(name=\\\"ad_addr1\\\")\\n    private String address1;\\n\\n    @Column(name=\\\"ad_addr2\\\")\\n    private String address2;\\n\\n    ....\\n}\\n\")), mdx(\"p\", null, \"which would be extracted to:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \"<resultMap>\\n   <id property=\\\"id\\\" column=\\\"ad_id\\\"/>\\n   <result property=\\\"address1\\\" column=\\\"ad_addr1\\\"/>\\n   <result property=\\\"address2\\\" column=\\\"ad_addr2\\\"/>\\n   ...\\n</resulMap>\\n\")), mdx(\"p\", null, \"As we can see, the resultMap is now updated with the appropriate column names. No more editing of resultMaps (at least for simple maps that is).\"), mdx(\"h4\", null, \"Collections and Associations\"), mdx(\"p\", null, \"There's still work that needs to be done in order to get Collections and Associations working properly. On a basic level they work well - but to allow for some best practices I've noticed - we need to provide \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"aliases\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"prefixes\"), \" to the result map entries.\"), mdx(\"h2\", null, \"SQL Statement Column Generation\"), mdx(\"p\", null, \"Another added feature was the ability to create \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<sql>\"), \" blocks containing the columns for INSERT, UPDATE and SELECT statements. The following menu features are available when working with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<resultMap>\"), \":\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Source > ResultMap SQL > Select columns\"), \"\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Source > ResultMap SQL > Insert columns\"), \"\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Source > ResultMap SQL > Update columns\"), \"\\nwhich will create the appropriate SQL blocks (respectively):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \"<sql id=\\\"addressMapSelectColumns>\\n    ad_addr1,\\n    ad_addr2,\\n    ...\\n</sql>\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \"<sql id=\\\"addressMapInsertColumns>\\n    (ad_addr1,\\n    ad_addr2,\\n    ...)\\n    values (#{address1},\\n    #{address2},\\n    ...\\n    )\\n</sql>\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \"<sql id=\\\"addressMapUpdateColumns>\\n    ad_addr1 = #{address1},\\n    ad_addr2 = #{address2},\\n    ...\\n</sql>\\n\")), mdx(\"p\", null, \"which can easily be used:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \"<select id=\\\"selectAddress\\\">\\n    select <include ref=\\\"addressMapSelectColumns\\\" />\\n    from address\\n</select>\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \"<insert id=\\\"insertAddress\\\" parameterType=\\\"Address\\\">\\n    insert into address\\n    <include ref=\\\"addressMapInsertColumns\\\" />\\n</insert>\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \"<insert id=\\\"updateAddress\\\" parameterType=\\\"Address\\\">\\n    update address\\n    set <include ref=\\\"addressMapUpdateColumns\\\" />\\n    where ...\\n</insert>\\n\")), mdx(\"h2\", null, \"Roadmap items\"), mdx(\"p\", null, \"I'm currently using this in my day-to-day, but there are some things that need to get added/update:\"), mdx(\"h3\", null, \"Handling Class Extension with Prefixes\"), mdx(\"p\", null, \"For example, right now base classes are not handled well. This probably won't affect many, but in our case our child objects contain prefixed column names in legacy, meaning that automating the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resultMap\"), \" still requires some manual intervention to update the column names coming from the parent object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"public class Parent {\\n    @Column(name=\\\"col1\\\")\\n    private String column1\\n}\\n\\npublic class Child extends parent {\\n    @Column(name=\\\"c_col2\\\")\\n    private String column2;\\n}\\n\")), mdx(\"p\", null, \"this will result in Child result map:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \"<resultMap type=\\\"Child\\\">\\n    <result property=\\\"column1\\\" column=\\\"col1\\\"/>\\n    <result property=\\\"column2\\\" column=\\\"c_col2\\\"/>\\n</resultMap>\\n\")), mdx(\"p\", null, \"where we actually want\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \"<resultMap type=\\\"Child\\\">\\n    <result property=\\\"column1\\\" column=\\\"c_col1\\\"/>\\n    <result property=\\\"column2\\\" column=\\\"c_col2\\\"/>\\n</resultMap>\\n\")), mdx(\"h3\", null, \"Collection and Association Mapping\"), mdx(\"p\", null, \"This is pretty crude at the moment. It would be good if it could support:\\nAliases\\nPrefixes\\nEtc.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"My Batipse  is a great Eclipse plugin that provides:\nValidation\nGeneration\nTools\nwhile working with Mybatis XML files. When I started at…","timeToRead":2,"banner":null}},"pageContext":{"slug":"/2018/10/01/mybatis-jpa-annotation-parsing","formatString":"MMM DD, yyyy"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}